#version 450

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer OutBuffer { uint data[]; };

layout(push_constant) uniform PC {
    uint elem_size;   // element size in bytes (1..8)
    uint value_lo;    // lower 32 bits of little-endian element value
    uint value_hi;    // upper 32 bits
} pc;

void main() {
    // Use the SSBO runtime length so the shader naturally stops at the buffer's size.
    uint total_words = uint(data.length());
    if (gl_GlobalInvocationID.x >= total_words) return;

    uint word_idx = gl_GlobalInvocationID.x;
    uint byte_base = word_idx * 4u;
    uint word = 0u;

    // total bytes (rounded up to number of words * 4). This may be >= actual byte-length
    // if the original buffer size wasn't a multiple of 4; the buffer binding should ensure
    // the storage range is correct so `data.length()` reflects how many words are addressable.
    uint total_bytes = total_words * 4u;

    for (uint b = 0u; b < 4u; ++b) {
        uint global_byte = byte_base + b;
        uint byte_val = 0u;
        if (global_byte < total_bytes) {
            // position within the repeating element
            uint pos = global_byte % pc.elem_size;
            if (pos < 4u) {
                byte_val = (pc.value_lo >> (pos * 8u)) & 0xFFu;
            } else {
                byte_val = (pc.value_hi >> ((pos - 4u) * 8u)) & 0xFFu;
            }
        }
        word |= (byte_val & 0xFFu) << (b * 8u);
    }

    data[word_idx] = word;
}