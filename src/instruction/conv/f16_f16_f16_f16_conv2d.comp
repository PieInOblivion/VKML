#version 450

#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

layout(std430, binding = 0) buffer SrcBuf { float16_t src[]; };
layout(std430, binding = 1) buffer WeightBuf { float16_t weight[]; };
layout(std430, binding = 2) buffer DstBuf { float16_t dst[]; };
layout(std430, binding = 3) buffer BiasBuf { float16_t bias[]; };

layout(push_constant) uniform PC {
    uint n;
    uint c;
    uint m;
    uint in_h;
    uint in_w;
    uint out_h;
    uint out_w;
    uint k_h;
    uint k_w;
    uint s_h;
    uint s_w;
    uint d_h;
    uint d_w;
    uint pad_h;
    uint pad_w;
    uint group;
    uint has_bias;
} pc;

void main() {
    uint ox = gl_GlobalInvocationID.x;
    uint oy = gl_GlobalInvocationID.y;
    uint oc = gl_GlobalInvocationID.z % pc.m; // use z for batch*oc mapping sometimes
    uint batch = gl_GlobalInvocationID.z / pc.m;

    if (ox >= pc.out_w || oy >= pc.out_h || oc >= pc.m || batch >= pc.n) return;

    float16_t acc = float16_t(0.0);

    uint m_per_group = pc.m / pc.group;
    uint c_per_group = pc.c / pc.group;
    uint group_id = oc / m_per_group;
    uint c_start = group_id * c_per_group;

    for (uint ic = c_start; ic < c_start + c_per_group; ++ic) {
        for (uint ky = 0u; ky < pc.k_h; ++ky) {
            int in_y_i = int(oy) * int(pc.s_h) - int(pc.pad_h) + int(ky) * int(pc.d_h);
            if (in_y_i < 0) continue;
            uint in_y = uint(in_y_i);
            if (in_y >= pc.in_h) continue;

            for (uint kx = 0u; kx < pc.k_w; ++kx) {
                int in_x_i = int(ox) * int(pc.s_w) - int(pc.pad_w) + int(kx) * int(pc.d_w);
                if (in_x_i < 0) continue;
                uint in_x = uint(in_x_i);
                if (in_x >= pc.in_w) continue;

                // src offset: (((batch * C + ic) * in_h + in_y) * in_w) + in_x
                uint src_off = (((batch * pc.c + ic) * pc.in_h + in_y) * pc.in_w) + in_x;

                // weight offset: (((oc * c_per_group + ic_in_group) * k_h + ky) * k_w) + kx
                uint ic_in_group = ic - c_start;
                uint w_off = (((oc * c_per_group + ic_in_group) * pc.k_h + ky) * pc.k_w) + kx;

                acc += src[src_off] * weight[w_off];
            }
        }
    }

    if (pc.has_bias != 0u) {
        acc += bias[oc];
    }

    // dst offset: (((batch * M + oc) * out_h + oy) * out_w) + ox
    uint dst_off = (((batch * pc.m + oc) * pc.out_h + oy) * pc.out_w) + ox;
    dst[dst_off] = acc;
}
