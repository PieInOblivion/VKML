#version 450

// 16x16 workgroup (256 threads), 16x16 tile, 4 KB ping-pong shared memory

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, binding = 0) buffer InBufferA { float a[]; };
layout(std430, binding = 1) buffer InBufferB { float b[]; };
layout(std430, binding = 2) buffer InBufferC { float c[]; };
layout(std430, binding = 3) buffer OutBuffer { float y[]; };

layout(push_constant) uniform PushConstants {
    uint m;
    uint k;
    uint n;
    uint stride_a0;
    uint stride_a1;
    uint stride_b0;
    uint stride_b1;
    uint stride_y0;
    uint stride_y1;
    uint trans_a;
    uint trans_b;
    float alpha;
    float beta;
    uint has_c;
} params;

shared float tileA[512];
shared float tileB[512];

void main() {
    uint tile_row = gl_WorkGroupID.y;
    uint tile_col = gl_WorkGroupID.x;

    uint thread_row = gl_LocalInvocationID.y;
    uint thread_col = gl_LocalInvocationID.x;

    uint out_row = tile_row * 16 + thread_row;
    uint out_col = tile_col * 16 + thread_col;

    float acc = 0.0;

    // Precompute transpose-dependent strides
    uint stride_a_k = (params.trans_a != 0) ? params.stride_a0 : params.stride_a1;
    uint stride_a_m = (params.trans_a != 0) ? params.stride_a1 : params.stride_a0;
    uint stride_b_k = (params.trans_b != 0) ? params.stride_b1 : params.stride_b0;
    uint stride_b_n = (params.trans_b != 0) ? params.stride_b0 : params.stride_b1;

    uint num_k_tiles = (params.k + 15) / 16;

    if (num_k_tiles == 0) {
        if (out_row < params.m && out_col < params.n) {
            float result = params.alpha * 0.0;
            if (params.has_c != 0) {
                uint c_idx = out_row * params.n + out_col;
                result += params.beta * c[c_idx];
            }
            uint y_idx = out_row * params.stride_y0 + out_col * params.stride_y1;
            y[y_idx] = result;
        }
        return;
    }

    uint tile_index = thread_row * 16 + thread_col;
    uint row_a = tile_row * 16 + thread_row;
    uint col_a_base = thread_col;
    uint row_b_base = thread_row;
    uint col_b = tile_col * 16 + thread_col;

    tileA[tile_index] = (row_a < params.m && col_a_base < params.k)
        ? a[row_a * stride_a_m + col_a_base * stride_a_k]
        : 0.0;
    tileB[tile_index] = (row_b_base < params.k && col_b < params.n)
        ? b[row_b_base * stride_b_k + col_b * stride_b_n]
        : 0.0;

    barrier();

    for (uint k_tile = 0; k_tile < num_k_tiles; k_tile++) {
        uint read_offset = (k_tile & 1u) * 256u;
        uint a_row_index = read_offset + thread_row * 16u;
        uint b_col_index = read_offset + thread_col;

        #pragma unroll 16
        for (uint ki = 0; ki < 16; ki++) {
            float a_val = tileA[a_row_index + ki];
            float b_val = tileB[b_col_index + ki * 16u];
            acc = fma(a_val, b_val, acc);
        }

        if (k_tile + 1u < num_k_tiles) {
            uint write_offset = ((k_tile + 1u) & 1u) * 256u;
            uint next_k_offset = (k_tile + 1u) * 16u;

            uint col_a = next_k_offset + col_a_base;
            uint row_b = next_k_offset + row_b_base;

            tileA[write_offset + tile_index] = (row_a < params.m && col_a < params.k)
                ? a[row_a * stride_a_m + col_a * stride_a_k]
                : 0.0;
            tileB[write_offset + tile_index] = (row_b < params.k && col_b < params.n)
                ? b[row_b * stride_b_k + col_b * stride_b_n]
                : 0.0;

            barrier();
        }
    }

    if (out_row < params.m && out_col < params.n) {
        float result = params.alpha * acc;
        if (params.has_c != 0) {
            uint c_idx = out_row * params.n + out_col;
            result += params.beta * c[c_idx];
        }
        uint y_idx = out_row * params.stride_y0 + out_col * params.stride_y1;
        y[y_idx] = result;
    }
}
