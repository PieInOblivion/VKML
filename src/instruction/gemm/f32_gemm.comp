#version 450

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

layout(std430, binding = 0) buffer InBufferA { float a[]; }; // Matrix A
layout(std430, binding = 1) buffer InBufferB { float b[]; }; // Matrix B
layout(std430, binding = 2) buffer InBufferC { float c[]; }; // Matrix C (optional)
layout(std430, binding = 3) buffer OutBuffer { float y[]; }; // Result Y

layout(push_constant) uniform PushConstants {
    uint m;             // Height of result
    uint k;             // Inner dimension
    uint n;             // Width of result
    uint stride_a0;     // Row stride for matrix A
    uint stride_a1;     // Column stride for matrix A
    uint stride_b0;     // Row stride for matrix B
    uint stride_b1;     // Column stride for matrix B
    uint stride_y0;     // Row stride for result Y
    uint stride_y1;     // Column stride for result Y
    uint trans_a;       // Transpose flag for A (0 or 1)
    uint trans_b;       // Transpose flag for B (0 or 1)
    float alpha;        // Scalar multiplier for A*B
    float beta;         // Scalar multiplier for C
    uint has_c;         // Whether C is provided (0 or 1)
} params;

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    // Check bounds
    if (row >= params.m || col >= params.n) {
        return;
    }

    float sum = 0.0;

    // Precompute transpose-dependent strides outside the loop
    uint stride_a_k = (params.trans_a != 0) ? params.stride_a0 : params.stride_a1;
    uint stride_a_m = (params.trans_a != 0) ? params.stride_a1 : params.stride_a0;
    uint stride_b_k = (params.trans_b != 0) ? params.stride_b1 : params.stride_b0;
    uint stride_b_n = (params.trans_b != 0) ? params.stride_b0 : params.stride_b1;

    // Matrix multiplication: compute element (row, col) of A*B
    for (uint i = 0; i < params.k; i++) {
        uint a_idx = row * stride_a_m + i * stride_a_k;
        uint b_idx = i * stride_b_k + col * stride_b_n;
        sum += a[a_idx] * b[b_idx];
    }

    // Compute Y[row, col] = alpha * sum + beta * C[row, col]
    float result = params.alpha * sum;

    if (params.has_c != 0) {
        // Add beta * C[row, col]
        uint c_idx = row * params.n + col;
        result += params.beta * c[c_idx];
    }

    // Store result
    uint y_idx = row * params.stride_y0 + col * params.stride_y1;
    y[y_idx] = result;
}
